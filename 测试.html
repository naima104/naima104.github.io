<!DOCTYPE html>
<html>
<head>
    <title>动态粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .panel {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
        }
        .slider-container { margin: 10px 0; }
        input[type="range"] { width: 200px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="panel">
        <h2>粒子系统控制</h2>
        <div class="slider-container">
            <div>粒子数量: <span id="particleCount">0</span></div>
            <input type="range" id="particleSlider" min="0" max="100000" value="0" step="1000">
        </div>
        <div>FPS: <span id="fps">0</span></div>
    </div>

<script>
class DynamicParticleSystem {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.targetCount = 0;
        this.currentCount = 0;
        this.resize();
        this.setupControls();
        this.lastTime = performance.now();
        this.frameCount = 0;
        this.lastFpsUpdate = 0;
        this.animate();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    setupControls() {
        const slider = document.getElementById('particleSlider');
        const counter = document.getElementById('particleCount');
        
        slider.addEventListener('input', (e) => {
            this.targetCount = parseInt(e.target.value);
            counter.textContent = this.targetCount.toLocaleString();
            
            // 平滑过渡到目标数量
            const diff = this.targetCount - this.currentCount;
            this.addParticles(diff);
        });
    }

    addParticles(count) {
        const { width, height } = this.canvas;
        const colors = [
            [255, 50, 50],   // 红
            [50, 255, 50],   // 绿
            [50, 50, 255],   // 蓝
            [255, 255, 50],  // 黄
            [255, 50, 255]   // 紫
        ];

        // 批量添加粒子
        const batchSize = Math.min(Math.abs(count), 5000); // 每批最多5000个
        const isAdding = count > 0;
        
        if (isAdding) {
            for (let i = 0; i < batchSize; i++) {
                this.particles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 2 + 1
                });
            }
            this.currentCount += batchSize;
        } else {
            this.particles.length = Math.max(0, this.particles.length - batchSize);
            this.currentCount = Math.max(0, this.currentCount - batchSize);
        }

        // 继续调整直到达到目标数量
        if (this.currentCount !== this.targetCount) {
            requestAnimationFrame(() => {
                this.addParticles(this.targetCount - this.currentCount);
            });
        }
    }

    update(delta) {
        const width = this.canvas.width;
        const height = this.canvas.height;

        // 更新现有粒子
        for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            
            p.x += p.vx * delta;
            p.y += p.vy * delta;
            
            // 边界反弹
            if (p.x < 0 || p.x > width) {
                p.vx *= -0.8;
                p.x = Math.max(0, Math.min(width, p.x));
            }
            if (p.y < 0 || p.y > height) {
                p.vy *= -0.8;
                p.y = Math.max(0, Math.min(height, p.y));
            }
            
            // 随机运动变化
            p.vx += (Math.random() - 0.5) * 0.1;
            p.vy += (Math.random() - 0.5) * 0.1;
            
            // 速度限制
            const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
            if (speed > 3) {
                p.vx = p.vx / speed * 3;
                p.vy = p.vy / speed * 3;
            }
        }
    }

    draw() {
        // 星空拖尾效果
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 批量绘制粒子
        for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            this.ctx.fillStyle = `rgb(${p.color[0]},${p.color[1]},${p.color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    animate(currentTime) {
        const delta = (currentTime - this.lastTime) / 16; // 转换为60fps基准
        this.lastTime = currentTime;
        this.frameCount++;

        // 每秒更新FPS
        if (currentTime - this.lastFpsUpdate >= 1000) {
            document.getElementById('fps').textContent = Math.round(
                this.frameCount * 1000 / (currentTime - this.lastFpsUpdate)
            );
            this.lastFpsUpdate = currentTime;
            this.frameCount = 0;
        }

        this.update(delta);
        this.draw();
        requestAnimationFrame(t => this.animate(t));
    }
}

// 启动系统
new DynamicParticleSystem();
</script>
</body>
</html>